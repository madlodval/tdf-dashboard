-- Drop views if they exist
DROP VIEW IF EXISTS aggregated_interval_volume;
DROP VIEW IF EXISTS aggregated_interval_liquidations;
DROP VIEW IF EXISTS aggregated_interval_open_interest;

DROP VIEW IF EXISTS aggregated_volume;
DROP VIEW IF EXISTS aggregated_liquidations;
DROP VIEW IF EXISTS aggregated_open_interest;

-- Drop tables if they exist (order matters due to foreign keys)
DROP TABLE IF EXISTS base_open_interest;
DROP TABLE IF EXISTS base_volume;
DROP TABLE IF EXISTS base_liquidations;
DROP TABLE IF EXISTS volume;
DROP TABLE IF EXISTS liquidations;
DROP TABLE IF EXISTS open_interest;
DROP TABLE IF EXISTS sync_liquidations;
DROP TABLE IF EXISTS sync_volume;
DROP TABLE IF EXISTS sync_open_interest;
DROP TABLE IF EXISTS intervals;
DROP TABLE IF EXISTS assets;
DROP TABLE IF EXISTS exchanges;


-- Create tables
CREATE TABLE exchanges (
  id SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- TINYINT UNSIGNED AUTO_INCREMENT -> SMALLINT GENERATED BY DEFAULT AS IDENTITY
  code VARCHAR(3) NOT NULL UNIQUE,
  name VARCHAR(64) NOT NULL UNIQUE
);

-- Add unique index explicitly (optional if UNIQUE constraint is used on column)
-- CREATE UNIQUE INDEX idx_exchange_code ON exchanges (code);


INSERT INTO exchanges (code, name) VALUES
('0', 'BitMEX'), ('2', 'Deribit'), ('3', 'OKX'), ('4', 'Huobi'), ('6', 'Bybit'),
('7', 'Phemex'), ('8', 'dYdX'), ('P', 'Poloniex'), ('V', 'Vertex'), ('D', 'Bitforex'),
('K', 'Kraken'), ('U', 'Bithumb'), ('B', 'Bitstamp'), ('H', 'Hyperliquid'), ('L', 'BitFlyer'),
('M', 'BtcMarkets'), ('I', 'Bit2c'), ('E', 'MercadoBitcoin'), ('N', 'Independent Reserve'),
('G', 'Gemini'), ('Y', 'Gate.io'), ('C', 'Coinbase'), ('F', 'Bitfinex'), ('J', 'Luno'),
('W', 'WOO X'), ('A', 'Binance');

CREATE TABLE intervals (
    id SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- TINYINT UNSIGNED AUTO_INCREMENT -> SMALLINT GENERATED BY DEFAULT AS IDENTITY
    name VARCHAR(16) NOT NULL UNIQUE,
    seconds INTEGER NOT NULL, -- INT UNSIGNED -> INTEGER
    is_base BOOLEAN DEFAULT NULL,
    enabled BOOLEAN DEFAULT TRUE
);

-- Add unique indexes explicitly (optional for UNIQUE constraint)
-- CREATE UNIQUE INDEX idx_interval_name ON intervals (name);
-- CREATE UNIQUE INDEX uk_one_base ON intervals (is_base); -- Note: This index allows only one row with is_base = TRUE, but multiple with NULL or FALSE


INSERT INTO intervals (name, seconds, is_base, enabled) VALUES
    ('1m', 60, NULL, FALSE),
    ('5m', 300, TRUE, TRUE),
    ('15m', 900, NULL, FALSE),
    ('30m', 1800, NULL, FALSE),
    ('1h', 3600, NULL, TRUE),
    ('2h', 7200, NULL, FALSE),
    ('4h', 14400, NULL, TRUE),
    ('6h', 21600, NULL, FALSE),
    ('12h', 43200, NULL, FALSE),
    ('1d', 86400, NULL, TRUE);


CREATE TABLE assets (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, -- SMALLINT UNSIGNED AUTO_INCREMENT -> INTEGER GENERATED BY DEFAULT AS IDENTITY
    symbol VARCHAR(20) NOT NULL UNIQUE,
    name VARCHAR(50) NOT NULL
);

-- Add unique index explicitly (optional for UNIQUE constraint)
-- CREATE UNIQUE INDEX idx_asset_symbol ON assets (symbol);


INSERT INTO assets (symbol, name) VALUES
    ('BTC', 'Bitcoin'),
    ('ETH', 'Ethereum'),
    ('SOL', 'Solana'),
    ('XRP', 'XRP'),
    ('BNB', 'BNB');


CREATE TABLE base_open_interest (
    exchange_id SMALLINT NOT NULL, -- TINYINT UNSIGNED -> SMALLINT
    asset_id INTEGER NOT NULL, -- SMALLINT UNSIGNED -> INTEGER
    timestamp BIGINT NOT NULL, -- BIGINT UNSIGNED -> BIGINT
    open_value DECIMAL(20, 8) NOT NULL,
    high_value DECIMAL(20, 8) NOT NULL,
    low_value DECIMAL(20, 8) NOT NULL,
    close_value DECIMAL(20, 8) NOT NULL,
    PRIMARY KEY (exchange_id, asset_id, timestamp),
    CONSTRAINT fk_oi_base_exchange FOREIGN KEY (exchange_id) REFERENCES exchanges(id),
    CONSTRAINT fk_oi_base_asset FOREIGN KEY (asset_id) REFERENCES assets(id)
);

-- Add index explicitly
CREATE INDEX idx_oi_base_asset_timestamp ON base_open_interest (asset_id, timestamp);


CREATE TABLE base_volume (
    exchange_id SMALLINT NOT NULL, -- TINYINT UNSIGNED -> SMALLINT
    asset_id INTEGER NOT NULL, -- SMALLINT UNSIGNED -> INTEGER
    timestamp BIGINT NOT NULL, -- BIGINT UNSIGNED -> BIGINT
    open_value DECIMAL(20, 8) NOT NULL,
    high_value DECIMAL(20, 8) NOT NULL,
    low_value DECIMAL(20, 8) NOT NULL,
    close_value DECIMAL(20, 8) NOT NULL,
    volume_value DECIMAL(20, 8),
    PRIMARY KEY (exchange_id, asset_id, timestamp),
    CONSTRAINT fk_vol_base_exchange FOREIGN KEY (exchange_id) REFERENCES exchanges(id),
    CONSTRAINT fk_vol_base_asset FOREIGN KEY (asset_id) REFERENCES assets(id)
);

-- Add index explicitly
CREATE INDEX idx_vol_base_asset_timestamp ON base_volume (asset_id, timestamp);


CREATE TABLE base_liquidations (
    exchange_id SMALLINT NOT NULL, -- TINYINT UNSIGNED -> SMALLINT
    asset_id INTEGER NOT NULL, -- SMALLINT UNSIGNED -> INTEGER
    timestamp BIGINT NOT NULL, -- BIGINT UNSIGNED -> BIGINT
    longs DECIMAL(20, 8) NOT NULL,
    shorts DECIMAL(20, 8) NOT NULL,
    PRIMARY KEY (exchange_id, asset_id, timestamp),
    CONSTRAINT fk_liq_base_exchange FOREIGN KEY (exchange_id) REFERENCES exchanges(id),
    CONSTRAINT fk_liq_base_asset FOREIGN KEY (asset_id) REFERENCES assets(id)
);

-- Add index explicitly
CREATE INDEX idx_liq_base_asset_timestamp ON base_liquidations (asset_id, timestamp);


CREATE TABLE open_interest (
    exchange_id SMALLINT NOT NULL, -- TINYINT UNSIGNED -> SMALLINT
    asset_id INTEGER NOT NULL, -- SMALLINT UNSIGNED -> INTEGER
    interval_id SMALLINT NOT NULL, -- TINYINT UNSIGNED -> SMALLINT
    timestamp BIGINT NOT NULL, -- BIGINT UNSIGNED -> BIGINT
    open_value DECIMAL(20, 8) NOT NULL,
    high_value DECIMAL(20, 8) NOT NULL,
    low_value DECIMAL(20, 8) NOT NULL,
    close_value DECIMAL(20, 8) NOT NULL,
    PRIMARY KEY (exchange_id, asset_id, interval_id, timestamp),
    CONSTRAINT fk_oi_exchange FOREIGN KEY (exchange_id) REFERENCES exchanges(id),
    CONSTRAINT fk_oi_asset FOREIGN KEY (asset_id) REFERENCES assets(id),
    CONSTRAINT fk_oi_interval FOREIGN KEY (interval_id) REFERENCES intervals(id)
);

-- Add index explicitly
CREATE INDEX idx_oi_asset_interval_timestamp ON open_interest (asset_id, interval_id, timestamp);


CREATE TABLE volume (
    exchange_id SMALLINT NOT NULL, -- TINYINT UNSIGNED -> SMALLINT
    asset_id INTEGER NOT NULL, -- SMALLINT UNSIGNED -> INTEGER
    interval_id SMALLINT NOT NULL, -- TINYINT UNSIGNED -> SMALLINT
    timestamp BIGINT NOT NULL, -- BIGINT UNSIGNED -> BIGINT
    open_value DECIMAL(20, 8) NOT NULL,
    high_value DECIMAL(20, 8) NOT NULL,
    low_value DECIMAL(20, 8) NOT NULL,
    close_value DECIMAL(20, 8) NOT NULL,
    volume_value DECIMAL(20, 8),
    PRIMARY KEY (exchange_id, asset_id, interval_id, timestamp),
    CONSTRAINT fk_vol_exchange FOREIGN KEY (exchange_id) REFERENCES exchanges(id),
    CONSTRAINT fk_vol_asset FOREIGN KEY (asset_id) REFERENCES assets(id),
    CONSTRAINT fk_vol_interval FOREIGN KEY (interval_id) REFERENCES intervals(id)
);

-- Add index explicitly
CREATE INDEX idx_vol_asset_interval_timestamp ON volume (asset_id, interval_id, timestamp);


CREATE TABLE liquidations (
    exchange_id SMALLINT NOT NULL, -- TINYINT UNSIGNED -> SMALLINT
    asset_id INTEGER NOT NULL, -- SMALLINT UNSIGNED -> INTEGER
    interval_id SMALLINT NOT NULL, -- TINYINT UNSIGNED -> SMALLINT
    timestamp BIGINT NOT NULL, -- BIGINT UNSIGNED -> BIGINT
    longs DECIMAL(20, 8) NOT NULL,
    shorts DECIMAL(20, 8) NOT NULL,
    PRIMARY KEY (exchange_id, asset_id, interval_id, timestamp),
    CONSTRAINT fk_liq_exchange FOREIGN KEY (exchange_id) REFERENCES exchanges(id),
    CONSTRAINT fk_liq_asset FOREIGN KEY (asset_id) REFERENCES assets(id),
    CONSTRAINT fk_liq_interval FOREIGN KEY (interval_id) REFERENCES intervals(id)
);

-- Add index explicitly
CREATE INDEX idx_liq_asset_interval_timestamp ON liquidations (asset_id, interval_id, timestamp);


CREATE TABLE sync_liquidations (
  asset_id INTEGER NOT NULL, -- SMALLINT UNSIGNED -> INTEGER
  interval_id SMALLINT NOT NULL, -- TINYINT UNSIGNED -> SMALLINT
  timestamp BIGINT NOT NULL DEFAULT 0, -- BIGINT UNSIGNED -> BIGINT
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, -- TIMESTAMP -> TIMESTAMP WITH TIME ZONE
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP -- ON UPDATE CURRENT_TIMESTAMP handled by trigger
);

-- Add primary key explicitly
ALTER TABLE sync_liquidations ADD PRIMARY KEY (asset_id, interval_id);

-- Add foreign keys explicitly
ALTER TABLE sync_liquidations ADD CONSTRAINT fk_sync_liq_interval FOREIGN KEY (interval_id) REFERENCES intervals(id);
ALTER TABLE sync_liquidations ADD CONSTRAINT fk_sync_liq_asset FOREIGN KEY (asset_id) REFERENCES assets(id);

-- Create trigger for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER sync_liquidations_updated_at
BEFORE UPDATE ON sync_liquidations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();


CREATE TABLE sync_volume (
  asset_id INTEGER NOT NULL, -- SMALLINT UNSIGNED -> INTEGER
  interval_id SMALLINT NOT NULL, -- TINYINT UNSIGNED -> SMALLINT
  timestamp BIGINT NOT NULL DEFAULT 0, -- BIGINT UNSIGNED -> BIGINT
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, -- TIMESTAMP -> TIMESTAMP WITH TIME ZONE
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP -- ON UPDATE CURRENT_TIMESTAMP handled by trigger
);

-- Add primary key explicitly
ALTER TABLE sync_volume ADD PRIMARY KEY (asset_id, interval_id);

-- Add foreign keys explicitly
ALTER TABLE sync_volume ADD CONSTRAINT fk_sync_vol_interval FOREIGN KEY (interval_id) REFERENCES intervals(id);
ALTER TABLE sync_volume ADD CONSTRAINT fk_sync_vol_asset FOREIGN KEY (asset_id) REFERENCES assets(id);

-- Create trigger for updated_at
CREATE TRIGGER sync_volume_updated_at
BEFORE UPDATE ON sync_volume
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();


CREATE TABLE sync_open_interest (
  asset_id INTEGER NOT NULL, -- SMALLINT UNSIGNED -> INTEGER
  interval_id SMALLINT NOT NULL, -- TINYINT UNSIGNED -> SMALLINT
  timestamp BIGINT NOT NULL DEFAULT 0, -- BIGINT UNSIGNED -> BIGINT
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, -- TIMESTAMP -> TIMESTAMP WITH TIME ZONE
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP -- ON UPDATE CURRENT_TIMESTAMP handled by trigger
);

-- Add primary key explicitly
ALTER TABLE sync_open_interest ADD PRIMARY KEY (asset_id, interval_id);

-- Add foreign keys explicitly
ALTER TABLE sync_open_interest ADD CONSTRAINT fk_sync_oi_interval FOREIGN KEY (interval_id) REFERENCES intervals(id);
ALTER TABLE sync_open_interest ADD CONSTRAINT fk_sync_oi_asset FOREIGN KEY (asset_id) REFERENCES assets(id);

-- Create trigger for updated_at
CREATE TRIGGER sync_open_interest_updated_at
BEFORE UPDATE ON sync_open_interest
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();


-- Create views
-- Note: SUBSTRING_INDEX and GROUP_CONCAT are replaced with ARRAY_AGG and indexing
CREATE VIEW aggregated_interval_volume AS
SELECT
    bv.exchange_id,
    bv.asset_id,
    i.id AS interval_id,
    i.seconds AS interval_duration_seconds,
    FLOOR(bv.timestamp / i.seconds) * i.seconds AS interval_timestamp,
    (ARRAY_AGG(bv.open_value ORDER BY bv.timestamp ASC))[1] AS open_value, -- Replaced SUBSTRING_INDEX(GROUP_CONCAT(open_value ORDER BY timestamp ASC), ',', 1)
    MAX(bv.high_value) AS high_value,
    MIN(bv.low_value) AS low_value,
    (ARRAY_AGG(bv.close_value ORDER BY bv.timestamp DESC))[1] AS close_value, -- Replaced SUBSTRING_INDEX(GROUP_CONCAT(close_value ORDER BY timestamp DESC), ',', 1)
    SUM(bv.volume_value) AS volume_value
FROM base_volume bv
JOIN intervals i ON TRUE -- Equivalent to ON 1=1
WHERE i.enabled
GROUP BY bv.exchange_id, bv.asset_id, i.id, interval_timestamp
HAVING COUNT(*) = (i.seconds / 300.0); -- Use 300.0 for floating point division


CREATE VIEW aggregated_interval_liquidations AS
SELECT
    bl.exchange_id,
    bl.asset_id,
    i.id AS interval_id,
    i.seconds AS interval_duration_seconds,
    FLOOR(bl.timestamp / i.seconds) * i.seconds AS interval_timestamp,
    SUM(bl.longs) AS longs,
    SUM(bl.shorts) AS shorts
FROM base_liquidations bl
JOIN intervals i ON TRUE -- Equivalent to ON 1=1
WHERE i.enabled
GROUP BY bl.exchange_id, bl.asset_id, i.id, interval_timestamp
HAVING COUNT(*) = (i.seconds / 300.0); -- Use 300.0 for floating point division

CREATE VIEW aggregated_interval_open_interest AS
SELECT
    oi.exchange_id,
    oi.asset_id,
    i.id as interval_id,
    i.seconds AS interval_duration_seconds,
    FLOOR(oi.timestamp / i.seconds) * i.seconds AS interval_timestamp,
    (ARRAY_AGG(oi.open_value ORDER BY oi.timestamp ASC))[1] AS open_value, -- Replaced SUBSTRING_INDEX(GROUP_CONCAT(open_value ORDER BY timestamp ASC), ',', 1)
    MAX(oi.high_value) AS high_value,
    MIN(oi.low_value) AS low_value,
    (ARRAY_AGG(oi.close_value ORDER BY oi.timestamp DESC))[1] AS close_value -- Replaced SUBSTRING_INDEX(GROUP_CONCAT(close_value ORDER BY timestamp DESC), ',', 1)
FROM base_open_interest oi
JOIN intervals i ON TRUE -- Equivalent to ON 1=1
WHERE i.enabled
GROUP BY oi.exchange_id, oi.asset_id, i.id, interval_timestamp
HAVING COUNT(*) = (i.seconds / 300.0); -- Use 300.0 for floating point division


CREATE VIEW aggregated_liquidations AS
SELECT
      asset_id,
      interval_id,
      timestamp,
      SUM(longs) AS longs,
      SUM(shorts) AS shorts
    FROM liquidations
    GROUP BY asset_id, interval_id, timestamp
    ORDER BY timestamp ASC;

CREATE VIEW aggregated_volume AS
 SELECT
       asset_id,
       interval_id,
       timestamp,
       AVG(open_value) AS open,
       AVG(high_value) AS high,
       AVG(low_value) AS low,
       AVG(close_value) AS close,
       SUM(volume_value) AS volume
     FROM volume
     GROUP BY asset_id, interval_id, timestamp
     ORDER BY timestamp ASC;


CREATE VIEW aggregated_open_interest AS
SELECT
      asset_id,
      interval_id,
      timestamp,
      SUM(open_value) AS open,
      SUM(high_value) AS high,
      SUM(low_value) AS low,
      SUM(close_value) AS close
    FROM open_interest
    GROUP BY asset_id, interval_id, timestamp
    ORDER BY timestamp ASC;


-- Stored Procedures (translated to PostgreSQL functions)

-- Function to sync volume intervals
CREATE OR REPLACE FUNCTION sync_volume_intervals(
    p_asset_id INTEGER, -- SMALLINT UNSIGNED -> INTEGER
    p_interval_id SMALLINT, -- TINYINT UNSIGNED -> SMALLINT
    p_interval_duration_seconds BIGINT, -- BIGINT -> BIGINT
    p_original_frequency_seconds BIGINT -- BIGINT -> BIGINT
)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
    v_last_sync_timestamp BIGINT;
    v_sync_start_timestamp BIGINT;
    row_count_var INT; -- Variable to store row count
BEGIN
    -- Get last sync timestamp
    SELECT timestamp INTO v_last_sync_timestamp
    FROM sync_volume
    WHERE asset_id = p_asset_id AND interval_id = p_interval_id;

    IF v_last_sync_timestamp IS NULL THEN
        v_last_sync_timestamp := 0;
    END IF;

    -- Calculate sync start timestamp
    v_sync_start_timestamp := v_last_sync_timestamp + p_interval_duration_seconds;

    -- Insert or update volume data
    INSERT INTO volume (
        exchange_id,
        asset_id,
        interval_id,
        timestamp,
        open_value,
        high_value,
        low_value,
        close_value,
        volume_value
    )
    SELECT
        exchange_id,
        asset_id,
        p_interval_id AS interval_id,
        FLOOR(timestamp / p_interval_duration_seconds) * p_interval_duration_seconds AS interval_timestamp,
        (ARRAY_AGG(open_value ORDER BY timestamp ASC))[1] AS open_value, -- Replaced SUBSTRING_INDEX(GROUP_CONCAT(...))
        MAX(high_value) AS high_value,
        MIN(low_value) AS low_value,
        (ARRAY_AGG(close_value ORDER BY timestamp DESC))[1] AS close_value, -- Replaced SUBSTRING_INDEX(GROUP_CONCAT(...))
        SUM(volume_value) AS volume_value
    FROM base_volume
    WHERE asset_id = p_asset_id AND timestamp >= v_sync_start_timestamp
    GROUP BY exchange_id, asset_id, interval_timestamp
    HAVING COUNT(*) = (p_interval_duration_seconds / p_original_frequency_seconds)
    ON CONFLICT (exchange_id, asset_id, interval_id, timestamp) DO UPDATE
    SET
        open_value = EXCLUDED.open_value,
        high_value = EXCLUDED.high_value,
        low_value = EXCLUDED.low_value,
        close_value = EXCLUDED.close_value,
        volume_value = EXCLUDED.volume_value;

    -- Get the number of rows affected by the last command
    GET DIAGNOSTICS row_count_var = ROW_COUNT;

    -- Update sync timestamp if rows were affected
    IF row_count_var > 0 THEN
        REPLACE INTO sync_volume (asset_id, interval_id, timestamp)
        SELECT p_asset_id, p_interval_id, COALESCE(MAX(timestamp), 0) FROM volume
        WHERE asset_id = p_asset_id AND interval_id = p_interval_id;
        -- Note: REPLACE INTO is not directly available in PostgreSQL.
        -- This is a common way to simulate it: delete then insert, or use ON CONFLICT.
        -- Using ON CONFLICT for sync tables as they have a simple primary key.
        -- The original MySQL REPLACE INTO on sync tables is like an UPSERT.
        -- Let's use ON CONFLICT for sync tables as well for consistency.
        INSERT INTO sync_volume (asset_id, interval_id, timestamp)
        SELECT p_asset_id, p_interval_id, COALESCE(MAX(timestamp), 0) FROM volume
        WHERE asset_id = p_asset_id AND interval_id = p_interval_id
        ON CONFLICT (asset_id, interval_id) DO UPDATE
        SET timestamp = EXCLUDED.timestamp;
    END IF;
END;
$$;


-- Function to sync liquidations intervals
CREATE OR REPLACE FUNCTION sync_liquidations_intervals(
    p_asset_id INTEGER, -- SMALLINT UNSIGNED -> INTEGER
    p_interval_id SMALLINT, -- TINYINT UNSIGNED -> SMALLINT
    p_interval_duration_seconds BIGINT, -- BIGINT -> BIGINT
    p_original_frequency_seconds BIGINT -- BIGINT -> BIGINT
)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
    v_last_sync_timestamp BIGINT;
    v_sync_start_timestamp BIGINT;
    row_count_var INT; -- Variable to store row count
BEGIN
    -- Get last sync timestamp
    SELECT timestamp INTO v_last_sync_timestamp
    FROM sync_liquidations
    WHERE asset_id = p_asset_id AND interval_id = p_interval_id;

    IF v_last_sync_timestamp IS NULL THEN
        v_last_sync_timestamp := 0;
    END IF;

    -- Calculate sync start timestamp
    v_sync_start_timestamp := v_last_sync_timestamp + p_interval_duration_seconds;

    -- Insert or update liquidations data
    INSERT INTO liquidations (
        exchange_id,
        asset_id,
        interval_id,
        timestamp,
        longs,
        shorts
    )
    SELECT
        exchange_id,
        asset_id,
        p_interval_id AS interval_id,
        FLOOR(timestamp / p_interval_duration_seconds) * p_interval_duration_seconds AS timestamp_interval,
        SUM(longs) AS longs,
        SUM(shorts) AS shorts
    FROM base_liquidations
    WHERE asset_id = p_asset_id AND timestamp >= v_sync_start_timestamp
    GROUP BY exchange_id, asset_id, timestamp_interval
    HAVING COUNT(*) = (p_interval_duration_seconds / p_original_frequency_seconds)
    ON CONFLICT (exchange_id, asset_id, interval_id, timestamp) DO UPDATE
    SET
        longs = EXCLUDED.longs,
        shorts = EXCLUDED.shorts;

    -- Get the number of rows affected by the last command
    GET DIAGNOSTICS row_count_var = ROW_COUNT;

    -- Update sync timestamp if rows were affected
    IF row_count_var > 0 THEN
        -- Using ON CONFLICT for sync tables
        INSERT INTO sync_liquidations (asset_id, interval_id, timestamp)
        SELECT p_asset_id, p_interval_id, COALESCE(MAX(timestamp), 0) FROM liquidations
        WHERE asset_id = p_asset_id AND interval_id = p_interval_id
        ON CONFLICT (asset_id, interval_id) DO UPDATE
        SET timestamp = EXCLUDED.timestamp;
    END IF;
END;
$$;


-- Function to sync open interest intervals
CREATE OR REPLACE FUNCTION sync_open_interest_intervals(
    p_asset_id INTEGER, -- SMALLINT UNSIGNED -> INTEGER
    p_interval_id SMALLINT, -- TINYINT UNSIGNED -> SMALLINT
    p_interval_duration_seconds BIGINT, -- BIGINT -> BIGINT
    p_original_frequency_seconds BIGINT -- BIGINT -> BIGINT
)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
    v_last_sync_timestamp BIGINT;
    v_sync_start_timestamp BIGINT;
    row_count_var INT; -- Variable to store row count
BEGIN
    -- Get last sync timestamp
    SELECT timestamp INTO v_last_sync_timestamp
    FROM sync_open_interest
    WHERE asset_id = p_asset_id AND interval_id = p_interval_id;

    IF v_last_sync_timestamp IS NULL THEN
        v_last_sync_timestamp := 0;
    END IF;

    -- Calculate sync start timestamp
    v_sync_start_timestamp := v_last_sync_timestamp + p_interval_duration_seconds;

    -- Insert or update open interest data
    INSERT INTO open_interest (
        exchange_id,
        asset_id,
        interval_id,
        timestamp,
        open_value,
        high_value,
        low_value,
        close_value
    )
    SELECT
        exchange_id,
        asset_id,
        p_interval_id AS interval_id,
        FLOOR(timestamp / p_interval_duration_seconds) * p_interval_duration_seconds AS interval_timestamp,
        (ARRAY_AGG(open_value ORDER BY timestamp ASC))[1] AS open_value, -- Replaced SUBSTRING_INDEX(GROUP_CONCAT(...))
        MAX(high_value) AS high_value,
        MIN(low_value) AS low_value,
        (ARRAY_AGG(close_value ORDER BY timestamp DESC))[1] AS close_value -- Replaced SUBSTRING_INDEX(GROUP_CONCAT(...))
    FROM base_open_interest
    WHERE asset_id = p_asset_id AND timestamp >= v_sync_start_timestamp
    GROUP BY exchange_id, asset_id, interval_timestamp
    HAVING COUNT(*) = (p_interval_duration_seconds / p_original_frequency_seconds)
    ON CONFLICT (exchange_id, asset_id, interval_id, timestamp) DO UPDATE
    SET
        open_value = EXCLUDED.open_value,
        high_value = EXCLUDED.high_value,
        low_value = EXCLUDED.low_value,
        close_value = EXCLUDED.close_value;

    -- Get the number of rows affected by the last command
    GET DIAGNOSTICS row_count_var = ROW_COUNT;

    -- Update sync timestamp if rows were affected
    IF row_count_var > 0 THEN
        -- Using ON CONFLICT for sync tables
        INSERT INTO sync_open_interest (asset_id, interval_id, timestamp)
        SELECT p_asset_id, p_interval_id, COALESCE(MAX(timestamp), 0) FROM open_interest
        WHERE asset_id = p_asset_id AND interval_id = p_interval_id
        ON CONFLICT (asset_id, interval_id) DO UPDATE
        SET timestamp = EXCLUDED.timestamp;
    END IF;
END;
$$;


-- Truncate tables (order matters due to foreign keys)
TRUNCATE TABLE open_interest CASCADE; -- Use CASCADE to truncate dependent tables
TRUNCATE TABLE volume CASCADE;
TRUNCATE TABLE liquidations CASCADE;
TRUNCATE TABLE base_open_interest CASCADE;
TRUNCATE TABLE base_volume CASCADE;
TRUNCATE TABLE base_liquidations CASCADE;
TRUNCATE TABLE sync_liquidations CASCADE;
TRUNCATE TABLE sync_volume CASCADE;
TRUNCATE TABLE sync_open_interest CASCADE;
-- Note: You might not want to truncate exchanges, intervals, and assets if they contain static data.
-- TRUNCATE TABLE exchanges CASCADE;
-- TRUNCATE TABLE intervals CASCADE;
-- TRUNCATE TABLE assets CASCADE;
